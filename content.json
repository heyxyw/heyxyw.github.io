[{"title":"SQL盲注","date":"2016-09-16T06:00:26.000Z","path":"2016/09/16/SQL盲注/","text":"前言在前段时间项目拿去做了一个入网安全测试,结果测出来例如SQL盲注,跨站点脚本攻击(XSS),跨站点伪造(CSRF) 等一系列问题.今天先对解决SQL盲注 问题做一个小的总结. 问题SQL盲注,相信大家都不会怎么陌生,如果没听说过得话,那么肯定听说过SQL注入.SQL盲注 是一种Web 系统的安全漏洞,属于比较严重的那种.SQL注入有很多种方式,而SQL盲注就是SQL注入的其中一种方式. 在安全级别中,SQL盲注是一种威胁程度很高的安全漏洞.用SQL查询语句去猜解表名、字段、数据等信息，使用外部输入来构造SQL 命令的全部或一部分，如果在用户输入中没有对SQL语法充分地除去或引用，那么生成的SQL可绕过安全性检查，或者插入其他用于修改后端数据库的语句，或者执行系统命令。错误的SQL也会被调用，并返回请求响应，攻击者利用这些漏洞进行系统攻击。 注入实例://请求地址 String getUrl=&quot;xxx.jsp?user=admin&amp;amp;password=1&apos; or &apos;1&apos;=&apos;1 &quot;; //接收参数 String user=request.getParameter(&quot;user&quot;); String password=request.getParameter(&quot;password&quot;); //拼装sql String checkSql=&quot;select count(*) from user where username=&apos;&quot;+user+&quot;&apos; and password =&apos;&quot;+password+&quot;&apos;&quot;; 获取参数合成后的sql变成了 select count(*) from users where userid=&apos;admin&apos; and passwd=&apos;1&apos; or &apos;1&apos;=&apos;1&apos; 这条SQL将会返回所有的记录数。 示例代码://注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取链接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbcdemo&quot;,&quot;root&quot;,&quot;admin&quot;); //模拟账号 String user=&quot;zhouq&quot;; //模拟密码 String password=&quot;1&apos; or &apos;1&apos;=&apos;1&quot;; //拼接 statement 需要执行的 sql StringBuilder sqlByStatement=new StringBuilder(&quot;select count(*) from user where &quot;); sqlByStatement.append(&quot; username=&apos;&quot;).append(user).append(&quot;&apos;&quot;); sqlByStatement.append(&quot; and password=&apos;&quot;).append(password).append(&quot;&apos;&quot;); //准备 PreparedStatement 执行的预编译 sql String sqlByPrepareStatement=&quot;select count(*) from user where username=? and password=?&quot;; Statement statement = conn.createStatement(); ResultSet query = statement.executeQuery(sqlByStatement.toString()); System.out.println(&quot;账户:&quot;+ user); System.out.println(&quot;密码:&quot;+ password); System.out.println(&quot;===========华丽的分割线===========&quot;); if(query.next()){ long count = query.getLong(1); System.out.println(&quot;Statement 查询结果:&quot; + count); } PreparedStatement ps = conn.prepareStatement(sqlByPrepareStatement); //设置第一个参数 ps.setString(1, user); //设置第二个参数 ps.setString(2, password); ResultSet resultSet = ps.executeQuery(); if(resultSet.next()){ long count = resultSet.getLong(1); System.out.println(&quot;PrepareStatement 查询结果: &quot; + count); } //资源关闭 操作... // 输出结果:账户:zhouq 密码:1&apos; or &apos;1&apos;=&apos;1 ===========华丽的分割线=========== Statement 查询结果:1 PrepareStatement 查询结果: 0 解决方案SQL注入攻击 是利用设计上的漏洞,在目标服务器上运行SQL语句进行攻击,动态生成SQL语句时没有对用户输入的数据进行验证是SQL注入攻击得逞的主要原因. 对于JDBC而言,SQL注入攻击只对 Statement 有效,对PreparedStatement是无效的,这是因为PreparedStatement不允许在插入时改变查询的逻辑结构.绕过验证,但这种手段只对Statement有效,对PreparedStatement无效. 尽量使用PreparedStatement 执行sql .例如上面的 SQL 查询语句.在 Statement 中 的sql 语句: select count(*) from user where username=&#39;admin&#39; and passwd=&#39;1&#39; or &#39;1&#39;=&#39;1&#39;.然后 statement.executeQuery(sql) 执行 ,在PreparedStatement 中 的sql 语句: select count(*) from user where username=? and password=? ,然后再对对应的 ? 赋值.Statement 是将整个sql 语句作为一个字符串链接到一起执行.PreparedStatement 中则 将 1&#39; or &#39;1&#39;=&#39;1 做为一个字符串 赋值给第二个 ? ,作为 “密码” 字段对应的值.这样一来 ,sql 注入就不存在了. 使用 ORM 框架. 如 Mybatis在 Mybatis 框架中. #{xx} ,使用的是PreparedStatement ,会有类型转换.也是比较安全的.select count(*) from user where username=#{username} and password=#{password}最终编译的sql为:select count(*) from user where username=? and password=? 结语：以上的这些,只是对最终sql 的处理.如果想彻底的防止SQL盲注 的系统.那么我们还需要对用户发过来的请求进行过滤,其中请求中的参数值很有可能包括一些危险的字符,这些字符就是我们需要去过滤处理的问题了.关于处理危险字符这些问题,又会涉及到 其他的漏洞 比如 XSS ,CSRF 等等.","tags":[{"name":"web安全","slug":"web安全","permalink":"https://heyxyw.github.io/tags/web安全/"},{"name":"SQL盲注","slug":"SQL盲注","permalink":"https://heyxyw.github.io/tags/SQL盲注/"}]},{"title":"Hello World","date":"2016-09-16T05:30:30.649Z","path":"2016/09/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]