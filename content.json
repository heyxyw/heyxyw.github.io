[{"title":"XSS 小结","date":"2016-09-16T06:00:26.000Z","path":"2016/09/16/XSS总结/","text":"前言上一篇文章中写了关于项目中处理SQL盲注的安全漏洞.其中也提到了XSS.这篇文章就来说一下XSS 是怎么来进行攻击的,如何对其进行防御. 概述XSS攻击：跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。 XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 `XSS`攻击的危害包括: 1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 3、盗窃企业重要的具有商业价值的资料 4、非法转账 5、强制发送电子邮件 6、网站挂马 7、控制受害者机器向其它网站发起攻击 —-摘自百度百科 XSS攻击 原理我们首先搭建一个简易的环境来模拟XSS 攻击 ,其中xssTest.jsp 代码如下 模拟XSS攻击实例 112345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"xssTestServltet\" method=\"get\"&gt; &lt;input type=\"txt\" name=\"userName\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;hr&gt; 您输入的账户为: $&#123;userName &#125;&lt;/body&gt;&lt;/html&gt; 后台处理 xssTestServlter.java1234567891011121314@WebServlet(\"/xssTestServltet\")public class XssTestServltet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接受参数 String userName=request.getParameter(\"userName\"); //存储数据到 作用域 request.setAttribute(\"userName\", userName!=null?userName:\"\"); //跳转到原页面. request.getRequestDispatcher(\"/xssTest.jsp\").forward(request, response); &#125;&#125; 然后我们请求到测试页面 我们尝试输入 qazxc110,得到的结果为: 此时页面源代码为: 我们注意到,我们的输入的字符被原封不动的显示在 15行的位置.那么我们试想一下,如果我们在输入框中输入 这样一段代码:&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;,会是什么样子.按照刚才的测试,那么这次源码中在刚才的位置就应该显示&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 这串代码相当于在展示的位置插入了一段javaScript 代码,那么就应该执行alert弹出弹窗 并打印 xss. 我们按照刚才的假设,在代码中实验.我们输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 这串代码在文本框中,然后提交页面.然后我得到了一下页面: 这时我们看到浏览器出现了弹窗,说明刚才的那段script 代码执行了.这个时候也就基本说明了,页面存在XSS 漏洞了.此时的页面源码为: 这是一种非常简单的方式.我们只是在页面上弹窗一个字符串而已,显然是执行了 &lt;script&gt;&lt;/script&gt;中的代码.那么这里面不但可以写弹窗代码,还可以写其他比如让页面跳转到一个指定的地址.如果这个地址的页面是一个跟当前页面相似的钓鱼页面的话,后果不堪设想. 很多网站都有留言模块.我们可以在留言板上插入一段恶意的代码,提交到后台.由于这段代码是保存在服务器上,若管理员并没有去及时发现并删除这段留言的代码,当范文留言列表的时候,留言会被加载出来.当用户访问这个留言的页面时,这段恶意代码就会执行.实例如下: 模拟XSS攻击实例 212345678910111213141516171819202122232425/** * 原页面访问地址. * */@WebServlet(\"/xssTestServltet\")public class XssTestServltet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接受参数 String userName=request.getParameter(\"userName\"); //存储数据到 作用域 request.setAttribute(\"userName\", userName!=null?userName:\"\"); //模拟存储一个cookie 到 客户端.在xss 攻击链接中获取. Cookie cookie = new Cookie(\"xxzx\",\"1234\"); response.addCookie(cookie); //模拟数据库中存储的留言. request.setAttribute(\"ly1\", \"xxzx\"); //模拟数据库中存储的留言.这里插入了一段 script 代码.去访问src 对应的xss 攻击 链接. request.setAttribute(\"ly2\", \"&lt;script src='http://localhost:8080/XssTestServlet2'&gt;&lt;/script&gt;么么哒\"); //跳转到原页面. request.getRequestDispatcher(\"/xssTest.jsp\").forward(request, response); &#125;&#125; 123456789101112131415161718192021/** * 模拟留言中 xss 攻击的 地址. * */@WebServlet(\"/XssTestServlet2\")public class XssTestServlet2 extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"访问了攻击地址.......\"); //得到cookies Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) &#123; System.out.println(\"name:\"+cookie.getName()); System.out.println(\"value:\"+cookie.getValue()); &#125; &#125;&#125; 这时我们任意用户在浏览器中访问 留言页面时,页面的代码: 在留言2 的后面,还去加载了一个 我们之前定义好的XSS 链接 .这样一来我们除了请求正常的地址,页面还另外请求了攻击的地址: 而在我们XSS 攻击地址的后台.我们获取到了这些信息: 当管理员进入后台来浏览留言时,就会触发,然后管理员的cookie 后后台地址 等等一系列信息都可以被拿到,然后攻击者就可以用一些cookie欺诈工具来更改管理员的cookie ,就可以不用输入账号,密码 也可以以管理员的身份登录进系统. 解决方案为解决上面出现的问题,现提供两种解决方案. 方案 1我们使用一个第三方的jar 包.调用第三方的api 来防止 XSS 攻击带来的危险.具体步骤如下: 首先,添加 apache 的commons-lang-2.6.jar . 然后,在后台调用 StringEscapeUtils.escapeHtml(string); StringEscapeUtils.escapeJavaScript(string); StringEscapeUtils.escapeSql(string); 对请求过来的参数进行转义,若还需要这些值到前台.我们可以使用；StringEscapeUtils.unescapeXXX(String);(XXX 可以表示 Html,JavaScript,Sql,Xml 等) 来进行反转义,或者在前台使用js 调用escape 可是可以的. 后台处理action:12345678@RequestMapping(\"/stringEscapeUtils\")public void stringEscapeUtils(HttpServletRequest request,HttpServletResponse response)&#123; String str=request.getParameter(\"username\"); System.out.println(\"username: \"+str); System.out.println(\"escapeSql: \"+StringEscapeUtils.escapeSql(str)); System.out.println(\"escapeHtml: \"+StringEscapeUtils.escapeHtml(str)); System.out.println(\"escapeJavaScript: \"+StringEscapeUtils.escapeJavaScript(str));&#125; 当我们前台输入:&lt;script&gt;alert(&#39;1&#39;)&lt;/script&gt; 时,后台的输出结果为: 注意:commons-lang-3.x 里面已经没有 escapeSql escapeJavaScript 方法,取而代之的是 escapeEcmaScript .具体的使用方法,就请自行验证了. 方案 2这里我们重点说一下方案二.这也是我们解决XSS 攻击时采用的一种方式. 前面我们说到 XSS 攻击无非就是我们对于参数的过滤没有做好.导致一些不安全的字符被原封不动的进入到我们的业务中.那么最终就是对参数进行过滤.在这种方案中.我们需要自己写一个Filter,使用Filter 来过滤发出的请求.对于每个post 的请求的参数过滤一些关键字,把他们替换成安全的.例如：&lt; &gt; &#39; &quot; \\ / # &amp; ,方法是实现一个自定义的 HttpServletRequestWrapper ,然后在Filter 里面调用它替换getParameter 方法即可,具体步骤如下. 首先 我们在后台添加一个 XssHttpServletRequestWrapper 类,让它继承 javax.servlet.http.HttpServletRequestWrapper ,代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.zhouq.filter.Xss;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;/** 对请求 的参数 进行 Xss 安全过滤 * @author zhouq * */public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; public XssHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; /** * 替换 getParameterValues */ public String[] getParameterValues(String parameter) &#123; String[] values = super.getParameterValues(parameter); if (values == null) &#123; return null; &#125; int count = values.length; String[] eccodedValues = new String[count]; // 对每个参数值进行 XSS 清理 for (int i = 0; i &lt; count; i++) &#123; eccodedValues[i] = cleanXSS(values[i]); &#125; return eccodedValues; &#125; /** * 替换 getParameter */ public String getParameter(String parameter)&#123; String value=super.getParameter(parameter); if(value!=null)&#123; //对参数值进行 XSS 清理 value=cleanXSS(value); &#125; return value; &#125; public String getHeader(String name) &#123; String value = super.getHeader(name); if (value == null) return null; return cleanXSS(value); &#125; /** XSS 清理 * @param value * @return */ private String cleanXSS(String value) &#123; System.out.println(\"清理前 :\"+value); value = value.replaceAll(\"&lt;\", \"&amp; lt;\").replaceAll(\"&gt;\", \"&amp; gt;\"); value = value.replaceAll(\"\\\\(\", \"&amp; #40;\").replaceAll(\"\\\\)\", \"&amp; #41;\"); value = value.replaceAll(\"'\", \"&amp; #39;\"); value = value.replaceAll(\"eval\\\\((.*)\\\\)\", \"\"); value = value.replaceAll(\"[\\\\\\\"\\\\\\'][\\\\s]*javascript:(.*)[\\\\\\\"\\\\\\']\", \"\\\"\\\"\"); value = value.replaceAll(\"script\", \"\"); System.out.println(\"清理后 :\"+value); System.out.println(\"----------------------------------------------------------\"); return value; &#125;&#125; 然后我们还需要在后台添加一个过滤器 XssFilter ,让它实现 javax.servlet.Filter,具体代码如下:12345678910111213141516171819202122232425262728293031package com.zhouq.filter.Xss;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;public class XssFilter implements Filter &#123; FilterConfig config = null; @Override public void destroy() &#123; this.config = null; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //执行 我们自己定义的 XssHttpServletRequestWrapper chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request), response); &#125; @Override public void init(FilterConfig config) throws ServletException &#123; this.config = config; &#125;&#125; 最后,我们还需要在web.xml 中应用 这个过滤器.web.xml 中的配置如下: 12345678910&lt;!-- 配置自实现的 XSS 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.zhouq.filter.Xss.XssFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;XssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;/filter-mapping&gt; 到这里.我们的 XSS 清理就编写完成了.每一次请求中的危险字符,敏感信息都会被过滤掉,您可以去测试一下是否对您的应用生效.当然了,如果您要处理更多的字符,那么您可以继续在 cleanXSS 中去添加你需要处理的东西.当然,需要注意的是,一些必要的字符不能被过滤,否则就改变了用户的真实数据.比如在我们当前系统中在为菜单添加操作的时候 会有前缀为javascript 的代码.那么这里就会被过滤掉.如果你应用中也出现这种情况,那么就得请您自己做取舍了. 假设登录页面有个输入用户名和密码的输入框，可以有很多 XSS CSRF 注入钓鱼网站 SQL注入等的攻击手段，例如：123456输入用户名 : &gt;\"'&gt;&lt;script&gt;alert(1779)&lt;/script&gt; 输入用户名: usera&gt;\"'&gt;&lt;img src=\"javascript:alert(23664)\"&gt; 输入用户名: \"'&gt;&lt;IMG SRC=\"/WF_XSRF.html--end_hig--begin_highlight_tag--hlight_tag--\"&gt; 输入用户名: usera'\"&gt;&lt;iframe src=\"http://demo.testfire.net--en--begin_highlight_tag--d_highlight_tag--\"&gt; 密码随意输入。 下面提供了一个登录页面的攻击实例，你可以通过下面的方式进行简单的测试: 用户名: `1&apos; or &apos;1&apos;=&apos;1` 密码:`&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;` 测试结果: 结束语到这里，XSS 攻击的防御措施就写完了，使用 Filter 的这种方式，不仅仅可以防御 XSS 攻击，还可以防御 CSRF 攻击，SQL注入 等安全问题。","tags":[{"name":"web安全","slug":"web安全","permalink":"https://heyxyw.github.io/tags/web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://heyxyw.github.io/tags/XSS/"}]},{"title":"SQL盲注","date":"2016-09-15T14:00:26.000Z","path":"2016/09/15/SQL盲注/","text":"前言在前段时间项目拿去做了一个入网安全测试,结果测出来例如SQL盲注,跨站点脚本攻击(XSS),跨站点伪造(CSRF) 等一系列问题.今天先对解决SQL盲注 问题做一个小的总结. 问题SQL盲注,相信大家都不会怎么陌生,如果没听说过得话,那么肯定听说过SQL注入.SQL盲注 是一种Web 系统的安全漏洞,属于比较严重的那种.SQL注入有很多种方式,而SQL盲注就是SQL注入的其中一种方式. 在安全级别中,SQL盲注是一种威胁程度很高的安全漏洞.用SQL查询语句去猜解表名、字段、数据等信息，使用外部输入来构造SQL 命令的全部或一部分，如果在用户输入中没有对SQL语法充分地除去或引用，那么生成的SQL可绕过安全性检查，或者插入其他用于修改后端数据库的语句，或者执行系统命令。错误的SQL也会被调用，并返回请求响应，攻击者利用这些漏洞进行系统攻击。 注入实例://请求地址 String getUrl=&quot;xxx.jsp?user=admin&amp;amp;password=1&apos; or &apos;1&apos;=&apos;1 &quot;; //接收参数 String user=request.getParameter(&quot;user&quot;); String password=request.getParameter(&quot;password&quot;); //拼装sql String checkSql=&quot;select count(*) from user where username=&apos;&quot;+user+&quot;&apos; and password =&apos;&quot;+password+&quot;&apos;&quot;; 获取参数合成后的sql变成了 select count(*) from users where userid=&apos;admin&apos; and passwd=&apos;1&apos; or &apos;1&apos;=&apos;1&apos; 这条SQL将会返回所有的记录数。 示例代码://注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取链接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbcdemo&quot;,&quot;root&quot;,&quot;admin&quot;); //模拟账号 String user=&quot;zhouq&quot;; //模拟密码 String password=&quot;1&apos; or &apos;1&apos;=&apos;1&quot;; //拼接 statement 需要执行的 sql StringBuilder sqlByStatement=new StringBuilder(&quot;select count(*) from user where &quot;); sqlByStatement.append(&quot; username=&apos;&quot;).append(user).append(&quot;&apos;&quot;); sqlByStatement.append(&quot; and password=&apos;&quot;).append(password).append(&quot;&apos;&quot;); //准备 PreparedStatement 执行的预编译 sql String sqlByPrepareStatement=&quot;select count(*) from user where username=? and password=?&quot;; Statement statement = conn.createStatement(); ResultSet query = statement.executeQuery(sqlByStatement.toString()); System.out.println(&quot;账户:&quot;+ user); System.out.println(&quot;密码:&quot;+ password); System.out.println(&quot;===========华丽的分割线===========&quot;); if(query.next()){ long count = query.getLong(1); System.out.println(&quot;Statement 查询结果:&quot; + count); } PreparedStatement ps = conn.prepareStatement(sqlByPrepareStatement); //设置第一个参数 ps.setString(1, user); //设置第二个参数 ps.setString(2, password); ResultSet resultSet = ps.executeQuery(); if(resultSet.next()){ long count = resultSet.getLong(1); System.out.println(&quot;PrepareStatement 查询结果: &quot; + count); } //资源关闭 操作... // 输出结果:账户:zhouq 密码:1&apos; or &apos;1&apos;=&apos;1 ===========华丽的分割线=========== Statement 查询结果:1 PrepareStatement 查询结果: 0 解决方案SQL注入攻击 是利用设计上的漏洞,在目标服务器上运行SQL语句进行攻击,动态生成SQL语句时没有对用户输入的数据进行验证是SQL注入攻击得逞的主要原因. 对于JDBC而言,SQL注入攻击只对 Statement 有效,对PreparedStatement是无效的,这是因为PreparedStatement不允许在插入时改变查询的逻辑结构.绕过验证,但这种手段只对Statement有效,对PreparedStatement无效. 尽量使用PreparedStatement 执行sql .例如上面的 SQL 查询语句.在 Statement 中 的sql 语句: select count(*) from user where username=&#39;admin&#39; and passwd=&#39;1&#39; or &#39;1&#39;=&#39;1&#39;.然后 statement.executeQuery(sql) 执行 ,在PreparedStatement 中 的sql 语句: select count(*) from user where username=? and password=? ,然后再对对应的 ? 赋值.Statement 是将整个sql 语句作为一个字符串链接到一起执行.PreparedStatement 中则 将 1&#39; or &#39;1&#39;=&#39;1 做为一个字符串 赋值给第二个 ? ,作为 “密码” 字段对应的值.这样一来 ,sql 注入就不存在了. 使用 ORM 框架. 如 Mybatis在 Mybatis 框架中. #{xx} ,使用的是PreparedStatement ,会有类型转换.也是比较安全的.select count(*) from user where username=#{username} and password=#{password}最终编译的sql为:select count(*) from user where username=? and password=? 结语：以上的这些,只是对最终sql 的处理.如果想彻底的防止SQL盲注 的系统.那么我们还需要对用户发过来的请求进行过滤,其中请求中的参数值很有可能包括一些危险的字符,这些字符就是我们需要去过滤处理的问题了.关于处理危险字符这些问题,又会涉及到 其他的漏洞 比如 XSS ,CSRF 等等.","tags":[{"name":"web安全","slug":"web安全","permalink":"https://heyxyw.github.io/tags/web安全/"},{"name":"SQL盲注","slug":"SQL盲注","permalink":"https://heyxyw.github.io/tags/SQL盲注/"}]},{"title":"Hello World","date":"2016-09-15T10:00:26.000Z","path":"2016/09/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]